//go:build ignore

// 为输入的枚举类型和包名，生成一个Go代码文件，该文件中包含一个枚举类型的映射，以及一个用于验证枚举类型的函数。
// 使用 go generate ./... 命令进行生成

package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"html/template"
	"log"
	"os"
)

const tmpl = `// Code generated by generate_const; DO NOT EDIT.
package {{.PkgName}}
var {{.TypeName}}Enum = map[{{.TypeName}}]string{
{{- range $key, $value := .Values }}
	{{$key}}: "{{$value}}",
{{- end }}
}
func (v {{.TypeName}})IsValid() bool {
	_, ok := {{.TypeName}}Enum[v]
	return ok
}
func (v {{.TypeName}})ValidValues() []int {
	var values []int
	for key := range {{.TypeName}}Enum {
		values = append(values, int(key))
	}
	return values
}
`

// main 是程序的入口，根据命令行参数生成枚举常量的Go代码文件。
// 它解析当前目录的AST，收集指定类型的常量值，并生成对应的枚举结构。
func main() {
	// 检查命令行参数数量，确保提供了类型名和包名，否则终止程序
	if len(os.Args) < 2 {
		log.Fatal("Usage: go run generate_const.go <type-name> <package-name>")
	}
	typeName := os.Args[1]
	pkgName := os.Args[2]

	fset := token.NewFileSet()
	// 解析当前目录下的Go源文件，收集所有包和文件的信息，包含注释以便后续处理
	pkgs, err := parser.ParseDir(fset, ".", nil, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}

	values := make(map[string]string)

	// 遍历所有包和文件，收集符合类型匹配的常量值
	for _, pkg := range pkgs {
		for _, file := range pkg.Files {
			ast.Inspect(file, func(n ast.Node) bool {
				decl, ok := n.(*ast.GenDecl)
				if !ok || decl.Tok != token.CONST {
					return true
				}

				// 遍历每个常量声明项，检查类型是否匹配目标类型名
				for _, spec := range decl.Specs {
					vspec := spec.(*ast.ValueSpec)
					if vspec.Type == nil {
						continue
					}

					if ident, ok := vspec.Type.(*ast.Ident); !ok || ident.Name != typeName {
						continue
					}

					// 遍历每个常量名称和对应的字面量值，将值和名称存入映射
					for i, name := range vspec.Names {
						if len(vspec.Values) <= i {
							continue
						}

						if lit, ok := vspec.Values[i].(*ast.BasicLit); ok {
							values[lit.Value] = name.Name
						}
					}
				}
				return true
			})
		}
	}

	// 加载并验证模板，准备生成代码所需的数据结构
	t := template.Must(template.New("enum").Parse(tmpl))
	data := map[string]interface{}{
		"PkgName":  pkgName,
		"TypeName": typeName,
		"Values":   values,
	}

	var buf bytes.Buffer
	// 执行模板生成原始代码内容
	if err := t.Execute(&buf, data); err != nil {
		log.Fatal(err)
	}

	// 格式化生成的Go代码
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatal(err)
	}

	// 将生成的代码写入指定文件，设置权限为0644
	filename := fmt.Sprintf("%s_enum_generated.go", typeName)
	if err := os.WriteFile(filename, formatted, 0644); err != nil {
		log.Fatal(err)
	}
}
