//go:build ignore

// 为querymodel目录下的结构体生成GenerateOptions()和GetField()方法
// 使用方法：go run querycontext_gen.go <struct-name>
// 例如：go run querycontext_gen.go ProblemQueryContext

package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

const queryModelTmpl = `// Code generated by generate_const; DO NOT EDIT.
package querycontext

import (
	"STUOJ/internal/model/option"
)

func (query *{{.StructName}}) GetField() option.FieldSelector {
	return &query.Field
}

func (query *{{.StructName}}) GetExtraFilters() *option.Filters {
	return &query.ExtraFilters
}

`

type FieldInfo struct {
	Name       string
	FieldConst string
	Operator   string
}

type TemplateData struct {
	StructName string
	Fields     []FieldInfo
	NeedsModel bool
	NeedsTime  bool
}

func main() {
	// 检查命令行参数
	if len(os.Args) < 2 {
		log.Fatal("Usage: go run querycontext_gen.go <struct-name>")
	}
	structName := os.Args[1]

	// 获取当前工作目录
	cwd, err := os.Getwd()
	if err != nil {
		log.Fatalf("获取当前工作目录失败: %v\n", err)
	}

	// 处理结构体
	err = processQueryContext(cwd, structName)
	if err != nil {
		log.Fatalf("处理查询模型失败: %v\n", err)
	}
}

// 处理查询模型的方法生成
func processQueryContext(dir string, structName string) error {
	// 查找querymodel目录
	// 使用相对路径，避免路径依赖
	queryModelDir := filepath.Join(dir)
	if _, err := os.Stat(queryModelDir); os.IsNotExist(err) {
		return fmt.Errorf("querymodel目录不存在: %s", queryModelDir)
	}

	// 查找所有querymodel文件
	files, err := os.ReadDir(queryModelDir)
	if err != nil {
		return fmt.Errorf("读取querymodel目录失败: %v", err)
	}

	// 查找目标结构体
	var targetFile string
	for _, file := range files {
		if file.IsDir() {
			continue
		}

		// 解析文件
		filePath := filepath.Join(queryModelDir, file.Name())
		fset := token.NewFileSet()
		node, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
		if err != nil {
			continue
		}

		// 查找结构体定义
		found := false
		ast.Inspect(node, func(n ast.Node) bool {
			typeSpec, ok := n.(*ast.TypeSpec)
			if !ok || typeSpec.Type == nil {
				return true
			}

			_, ok = typeSpec.Type.(*ast.StructType)
			if !ok {
				return true
			}

			// 找到目标结构体
			if typeSpec.Name.Name == structName {
				found = true
				targetFile = filePath
				return false
			}
			return true
		})

		if found {
			break
		}
	}

	if targetFile == "" {
		return fmt.Errorf("在querymodel目录中未找到结构体: %s", structName)
	}

	// 解析目标文件
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, targetFile, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("解析文件 %s 失败: %v", targetFile, err)
	}

	// 提取结构体字段
	var fields []FieldInfo
	needsModel := false
	needsTime := false
	ast.Inspect(node, func(n ast.Node) bool {
		typeSpec, ok := n.(*ast.TypeSpec)
		if !ok || typeSpec.Type == nil || typeSpec.Name.Name != structName {
			return true
		}

		structType, ok := typeSpec.Type.(*ast.StructType)
		if !ok {
			return false
		}

		// 遍历结构体字段
		for _, field := range structType.Fields.List {
			if len(field.Names) == 0 {
				continue
			}

			fieldName := field.Names[0].Name
			// 跳过Page、Sort和Field字段
			if fieldName == "Page" || fieldName == "Sort" || fieldName == "Field" {
				continue
			}

			// 确定字段类型和操作符
			var fieldType string
			var operator string
			var fieldConst string

			// 解析字段类型
			switch expr := field.Type.(type) {
			case *ast.SelectorExpr:
				if ident, ok := expr.X.(*ast.Ident); ok {
					if ident.Name == "model" {
						fieldType = expr.Sel.Name
						needsModel = true
					} else if ident.Name == "time" && expr.Sel.Name == "Time" {
						needsTime = true
					}
				}
			case *ast.IndexExpr:
				if sel, ok := expr.X.(*ast.SelectorExpr); ok {
					if ident, ok := sel.X.(*ast.Ident); ok {
						if ident.Name == "model" {
							fieldType = sel.Sel.Name
							needsModel = true
						}
						// 检查索引表达式中的类型参数是否为time.Time
						if typeArg, ok := expr.Index.(*ast.SelectorExpr); ok {
							if typeArgIdent, ok := typeArg.X.(*ast.Ident); ok && typeArgIdent.Name == "time" && typeArg.Sel.Name == "Time" {
								needsTime = true
							}
						}
					}
				}
			}

			// 根据字段名确定字段常量
			entityName := strings.TrimSuffix(structName, "QueryContext")
			fieldConst = entityName + fieldName

			// 根据字段类型确定操作符
			switch {
			case fieldType == "Field":
				operator = "option.OpLike"
			case fieldType == "FieldList":
				operator = "option.OpIn"
			default:
				operator = "option.OpEq"
			}

			// 特殊处理StartTime和EndTime字段
			if fieldName == "StartTime" {
				fieldConst = entityName + "CreateTime"
				operator = "option.OpGreaterEq"
				needsTime = true
			} else if fieldName == "EndTime" {
				fieldConst = entityName + "CreateTime"
				operator = "option.OpLessEq"
				needsTime = true
			}

			fields = append(fields, FieldInfo{
				Name:       fieldName,
				FieldConst: fieldConst,
				Operator:   operator,
			})
		}

		return false
	})

	// 准备模板数据
	templateData := TemplateData{
		StructName: structName,
		Fields:     fields,
		NeedsModel: needsModel,
		NeedsTime:  needsTime,
	}

	// 渲染模板
	tmpl, err := template.New("querycontext").Parse(queryModelTmpl)
	if err != nil {
		return fmt.Errorf("解析模板失败: %v", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, templateData); err != nil {
		return fmt.Errorf("渲染模板失败: %v", err)
	}

	// 格式化代码
	formattedCode, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("格式化代码失败: %v\n%s", err, buf.String())
	}

	fileName := strings.ToLower(structName) + "_generated.go"

	// 写入文件
	outputFile := filepath.Join(queryModelDir, fileName)
	if err := os.WriteFile(outputFile, formattedCode, 0644); err != nil {
		return fmt.Errorf("写入文件 %s 失败: %v", outputFile, err)
	}

	fmt.Printf("生成成功: %s\n", fileName)
	return nil
}
