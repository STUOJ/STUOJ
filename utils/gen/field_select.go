package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"
)

func main() {
	structName := flag.String("struct", "", "结构体名称")
	flag.Parse()
	if *structName == "" {
		log.Fatal("必须指定 -struct 参数")
	}
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, ".", nil, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}
	var (
		targetStruct *ast.StructType
		pkgName      string
		tableName    string
	)
	// 查找目标结构体和TableName方法
	for _, pkgFiles := range pkgs {
		for _, file := range pkgFiles.Files {
			// 查找结构体定义
			for _, decl := range file.Decls {
				genDecl, ok := decl.(*ast.GenDecl)
				if !ok || genDecl.Tok != token.TYPE {
					continue
				}
				for _, spec := range genDecl.Specs {
					typeSpec, ok := spec.(*ast.TypeSpec)
					if !ok || typeSpec.Name.Name != *structName {
						continue
					}
					if structType, ok := typeSpec.Type.(*ast.StructType); ok {
						targetStruct = structType
						pkgName = "field\n"
					}
				}
			}
			// 查找TableName方法
			for _, decl := range file.Decls {
				fn, ok := decl.(*ast.FuncDecl)
				if !ok || fn.Name.Name != "TableName" {
					continue
				}
				// 检查接收器类型
				if fn.Recv == nil || len(fn.Recv.List) == 0 {
					continue
				}
				recvType := fn.Recv.List[0].Type
				if starExpr, ok := recvType.(*ast.StarExpr); ok {
					recvType = starExpr.X
				}
				if ident, ok := recvType.(*ast.Ident); ok && ident.Name == *structName {
					// 验证返回类型
					if fn.Type.Results == nil || len(fn.Type.Results.List) != 1 {
						log.Fatal("TableName 方法必须返回一个字符串")
					}
					// 提取表名
					for _, stmt := range fn.Body.List {
						retStmt, ok := stmt.(*ast.ReturnStmt)
						if !ok {
							continue
						}
						if len(retStmt.Results) != 1 {
							continue
						}
						if lit, ok := retStmt.Results[0].(*ast.BasicLit); ok && lit.Kind == token.STRING {
							tableName = strings.Trim(lit.Value, `"`)
							break
						}
					}
				}
			}
		}
	}
	if targetStruct == nil {
		log.Fatalf("找不到结构体: %s", *structName)
	}
	if tableName == "" {
		log.Fatalf("结构体 %s 缺少 TableName 方法", *structName)
	}
	// 解析结构体字段
	var fields []FieldInfo
	for _, f := range targetStruct.Fields.List {
		if len(f.Names) == 0 {
			continue
		}
		fieldName := f.Names[0].Name
		if f.Tag == nil {
			continue
		}
		gormTag := getGormTag(f.Tag.Value)
		if hasForeignKey(gormTag) {
			continue
		}
		fields = append(fields, FieldInfo{Name: fieldName})
	}
	// 创建输出目录
	outputDir := "field"
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		log.Fatal(err)
	}
	// 生成代码
	outputPath := filepath.Join(outputDir, strings.ToLower(*structName)+"_field_generated.go")
	tmpl := template.Must(template.New("").
		Funcs(template.FuncMap{"toSnake": toSnakeCase}).
		Parse(templateStr))
	data := map[string]interface{}{
		"Package":    pkgName,
		"StructName": *structName,
		"TableName":  tableName,
		"Fields":     fields,
	}
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		log.Fatal(err)
	}
	if err := os.WriteFile(outputPath, buf.Bytes(), 0644); err != nil {
		log.Fatal(err)
	}
	fmt.Printf("生成成功: %s\n", outputPath)
}

type FieldInfo struct {
	Name string
}

func getGormTag(tag string) string {
	tag = strings.Trim(tag, "`")
	for _, part := range strings.Split(tag, " ") {
		if strings.HasPrefix(part, "gorm:") {
			return strings.Trim(strings.SplitN(part, ":", 2)[1], `"`)
		}
	}
	return ""
}
func hasForeignKey(tag string) bool {
	for _, part := range strings.Split(tag, ";") {
		if strings.HasPrefix(strings.TrimSpace(part), "foreignKey:") {
			return true
		}
	}
	return false
}
func toSnakeCase(s string) string {
	matchFirstCap := regexp.MustCompile("(.)([A-Z][a-z]+)")
	matchAllCap := regexp.MustCompile("([a-z0-9])([A-Z])")
	snake := matchFirstCap.ReplaceAllString(s, "${1}_${2}")
	snake = matchAllCap.ReplaceAllString(snake, "${1}_${2}")
	return strings.ToLower(snake)
}

const templateStr = `// Code generated by generate_const; DO NOT EDIT.
package {{.Package}}
type {{.StructName}}Field struct {
{{- range .Fields }}
    {{ .Name }} bool
{{- end }}
}

func (f *{{.StructName}}Field) SelectedColumns() []string {
    columns := make([]string, 0)
{{- range .Fields }}
    if f.{{ .Name }} {
        columns = append(columns, "{{ $.TableName }}.{{ .Name | toSnake }}")
    }
{{- end }}
    return columns
}

{{ range .Fields }}
func (f *{{$.StructName}}Field) Select{{ .Name }}() *{{$.StructName}}Field {
    f.{{ .Name }} = true
    return f
}
{{- end }}

func (f *{{$.StructName}}Field) SelectAll() *{{$.StructName}}Field{
{{- range .Fields }}
    f.{{ .Name }} = true
{{- end }}
    return f
}`
