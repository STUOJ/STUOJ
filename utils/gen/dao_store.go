//go:build ignore

// 为输入的枚举类型和包名，生成一个Go代码文件，该文件中包含一个枚举类型的映射，以及一个用于验证枚举类型的函数。
// 使用 go generate ./... 命令进行生成

package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"html/template"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

const tmpl = `// Code generated by generate_const; DO NOT EDIT.
package dao

import (
	"STUOJ/internal/db"
	"STUOJ/internal/db/entity"
	"STUOJ/internal/db/query/model"
	"gorm.io/gorm"
)

type _{{.StructName}}Store struct {}

var {{.StructName}}Store = new(_{{.StructName}}Store)

// 插入记录
func (store *_{{.StructName}}Store) Insert(entity_ entity.{{.StructName}}) (entity.{{.StructName}}, error) {
	err := db.Db.Transaction(func(tx *gorm.DB) error {
		return tx.Create(&entity_).Error
	})
	return entity_, err
}

// 查询记录
func (store *_{{.StructName}}Store) Select(option model.QueryOptions) ([]entity.{{.StructName}}, error) {
	var entities []entity.{{.StructName}}
	where := option.GenerateQuery()
	err := db.Db.Transaction(func(tx *gorm.DB) error {
		return tx.Model(&entity.{{.StructName}}{}).Where(where).Find(&entities).Error
	})
	return entities, err
}

// 查询单条记录
func (store *_{{.StructName}}Store) SelectOne(option model.QueryOptions) (entity.{{.StructName}}, error) {
	var entity_ entity.{{.StructName}}
	where := option.GenerateQuery()
	err := db.Db.Transaction(func(tx *gorm.DB) error {
		return tx.Model(&entity.{{.StructName}}{}).Where(where).First(&entity_).Error
	})
	return entity_, err
}

// 更新记录
func (store *_{{.StructName}}Store) Updates(entity_ entity.{{.StructName}}, option model.QueryOptions) (int64, error) {
	var affected int64
	where := option.GenerateQuery()
	err := db.Db.Transaction(func(tx *gorm.DB) error {
		res := tx.Model(&entity.{{.StructName}}{}).Where(where).Updates(entity_)
		affected = res.RowsAffected
		return res.Error
	})
	return affected, err
}

// 删除记录
func (store *_{{.StructName}}Store) Delete(option model.QueryOptions) error {
	where := option.GenerateQuery()
	return db.Db.Transaction(func(tx *gorm.DB) error {
		return tx.Where(where).Delete(&entity.{{.StructName}}{}).Error
	})
}

// 统计数量
func (store *_{{.StructName}}Store) Count(option model.QueryOptions) (int64, error) {
	var count int64
	where := option.GenerateQuery()
	err := db.Db.Transaction(func(tx *gorm.DB) error {
		return tx.Model(&entity.{{.StructName}}{}).Where(where).Count(&count).Error
	})
	return count, err
}`

func main() {
	// 解析命令行参数
	var (
		typeName string
	)
	flag.StringVar(&typeName, "struct", "", "结构体类型名称")
	flag.Parse()

	// 校验参数
	if typeName == "" {
		log.Fatal("必须指定-type参数")
	}

	fset := token.NewFileSet()

	pkgs, err := parser.ParseDir(fset, ".", nil, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}
	var (
		targetStruct *ast.StructType
	)

	// 查找目标结构体
	for _, pkgFiles := range pkgs {
		for _, file := range pkgFiles.Files {
			for _, decl := range file.Decls {
				genDecl, ok := decl.(*ast.GenDecl)
				if !ok || genDecl.Tok != token.TYPE {
					continue
				}
				for _, spec := range genDecl.Specs {
					typeSpec, ok := spec.(*ast.TypeSpec)
					if !ok || typeSpec.Name.Name != typeName {
						continue
					}
					if structType, ok := typeSpec.Type.(*ast.StructType); ok {
						targetStruct = structType
						break
					}
				}
			}
		}
	}

	if targetStruct == nil {
		log.Fatalf("未找到类型 %s 对应的结构体", typeName)
	}

	// 创建输出目录
	outputDir := "../dao"
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		log.Fatal(err)
	}

	// 创建模板并渲染
	t := template.Must(template.New("dao").Parse(tmpl))
	outputFile := filepath.Join(outputDir, fmt.Sprintf("%s_store_generated.go", snakeCase(typeName)))
	f, err := os.Create(outputFile)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	err = t.Execute(f, struct {
		StructName string
	}{
		StructName: typeName,
	})
	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf("生成成功: %s\n", outputFile)
}

func snakeCase(s string) string {
	var matchFirstCap = regexp.MustCompile("(.)([A-Z][a-z]+)")
	var matchAllCap = regexp.MustCompile("([a-z0-9])([A-Z])")

	snake := matchFirstCap.ReplaceAllString(s, "${1}_${2}")
	snake = matchAllCap.ReplaceAllString(snake, "${1}_${2}")
	return strings.ToLower(snake)
}
