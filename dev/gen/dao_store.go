//go:build ignore

// 为输入的枚举类型和包名，生成一个Go代码文件，该文件中包含一个枚举类型的映射，以及一个用于验证枚举类型的函数。
// 使用 go generate ./... 命令进行生成

package main

import (
	"STUOJ/pkg/utils"
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"html/template"
	"log"
	"os"
	"path/filepath"
	"strings"
)

const tmpl = `// Code generated by generate_const; DO NOT EDIT.
package dao

import (
	"STUOJ/internal/infrastructure/repository"
	"STUOJ/internal/infrastructure/repository/entity"
	"STUOJ/internal/model/option"
	"gorm.io/gorm"
	{{- range.Imports}}
	"{{.}}"
	{{- end}}
)

type _{{.StructName}}Store struct {}

var {{.StructName}}Store = new(_{{.StructName}}Store)

// 插入记录
func (store *_{{.StructName}}Store) Insert(entity_ entity.{{.StructName}}) (entity.{{.StructName}}, error) {
	err := repository.Db.Transaction(func(tx *gorm.DB) error {
		return tx.Create(&entity_).Error
	})
	return entity_, err
}

// 查询记录
func (store *_{{.StructName}}Store) Select(options *option.QueryOptions) ([]map[string]any, error) {
	var entities []map[string]any
	where := options.GenerateQuery()
	err := repository.Db.Transaction(func(tx *gorm.DB) error {
		tx = tx.Model(&entity.{{.StructName}}{})
		tx = where(tx)
		return tx.Scan(&entities).Error
	})
	return entities, err
}

// 查询单条记录
func (store *_{{.StructName}}Store) SelectOne(options *option.QueryOptions) (map[string]any, error) {
	var entity_ map[string]any
	where := options.GenerateQuery()
	err := repository.Db.Transaction(func(tx *gorm.DB) error {
		tx = tx.Model(&entity.{{.StructName}}{})
		tx = where(tx)
		return tx.Scan(&entity_).Error
	})
	return entity_, err
}

// 更新记录
func (store *_{{.StructName}}Store) Updates(entity_ entity.{{.StructName}}, options *option.QueryOptions) (int64, error) {
	var affected int64
	where := options.GenerateQuery()
	err := repository.Db.Transaction(func(tx *gorm.DB) error {
		tx = tx.Model(&entity.{{.StructName}}{})
		tx = where(tx)
		res := tx.Updates(entity_)
		affected = res.RowsAffected
		return res.Error
	})
	return affected, err
}

// 删除记录
func (store *_{{.StructName}}Store) Delete(options *option.QueryOptions) error {
	where := options.GenerateQuery()
	return repository.Db.Transaction(func(tx *gorm.DB) error {
		tx = tx.Model(&entity.{{.StructName}}{})
		tx = where(tx)
		return tx.Delete(&entity.{{.StructName}}{}).Error
	})
}

// 统计数量
func (store *_{{.StructName}}Store) Count(options *option.QueryOptions) (int64, error) {
	var count int64
	where := options.GenerateQuery()
	err := repository.Db.Transaction(func(tx *gorm.DB) error {
		tx = tx.Model(&entity.{{.StructName}}{})
		tx = where(tx)
		return tx.Count(&count).Error
	})
	return count, err
}

func (store *_{{.StructName}}Store) GroupCount(options *option.GroupCountOptions)([]option.GroupCountResult, error){
	var res []option.GroupCountResult
	where := options.GenerateQuery()
	err := repository.Db.Transaction(func(tx *gorm.DB) error {
		tx = tx.Model(&entity.{{.StructName}}{})
		tx = where(tx)
		return tx.Scan(&res).Error
	})
	return res, err
}

func (store *_{{.StructName}}Store) Dto(data map[string]any) entity.{{.StructName}} {
	var entity_ entity.{{.StructName}}
	{{- range .Fields}}
	{{- if .PkgPath}}
	if v, ok := data["{{.Name | toSnake}}"].({{.PkgPath}}.{{.Type}}); ok {
		entity_.{{.Name}} = v
	}
	{{- else}}
	if v, ok := data["{{.Name | toSnake}}"].({{.Type}}); ok {
		entity_.{{.Name}} = v
	}
	{{- end}}
	{{- end}}
	return entity_
}

{{- range.Fields}}
{{if .EntityType}}
// StringTo{{.Type}}Slice converts a comma-separated string to a slice of entity.{{.Type}}.
func StringTo{{.Type}}Slice(s string) ([]entity.{{.Type}}, error) {
	if s == "" {
		return nil, nil
	}
	var res []entity.{{.Type}}
	parts := strings.Split(s, ",")
	for _, p := range parts {
		p = strings.TrimSpace(p)
		if p == "" {
			continue
		}
		{{if eq .StrconvFunc "ParseBool"}}
		val, err := strconv.ParseBool(p)
		{{else if .StrconvFunc}}
		parsedVal, err := strconv.{{.StrconvFunc}}(p, {{.StrconvBase}}, {{.StrconvBitSize}})
		if err != nil {
			return nil, fmt.Errorf("failed to parse '%s' as {{.UnderlyingType}} for {{.Type}}: %w", p, err)
		}
		val := entity.{{.Type}}(parsedVal)
		{{else}}
		// Fallback or error for unsupported types - this should ideally not be reached if getUnderlyingTypeInfo is comprehensive
		return nil, fmt.Errorf("unsupported underlying type for {{.Type}}: {{.UnderlyingType}}")
		{{end}}
		res = append(res, val)
	}
	return res, nil
}
{{end}}
{{end}}
`

type TemplateData struct {
	StructName string
	Fields     []FieldInfo
	Imports    []string
}

type FieldInfo struct {
	Name           string
	Type           string // The original type name, e.g., "BlogStatus"
	PkgPath        string
	EntityType     bool
	ParamName      string
	UnderlyingType string // The underlying base type, e.g., "uint8"
	StrconvFunc    string // The strconv function to use, e.g., "ParseUint"
	StrconvBase    int    // The base for strconv function (0, 8, 10, 16, etc.)
	StrconvBitSize int    // The bit size for strconv function (0, 8, 16, 32, 64)
}

func main() {
	// 解析命令行参数
	var (
		structName string
	)
	flag.StringVar(&structName, "struct", "", "结构体类型名称")
	flag.Parse()

	// 校验参数
	if structName == "" {
		log.Fatal("必须指定-type参数")
	}

	dir, err := os.Getwd()
	if err != nil {
		log.Fatal("获取当前工作目录失败: %v\n", err)
	}

	file := os.Getenv("GOFILE")
	entityFile := filepath.Join(dir, file)

	fset := token.NewFileSet()

	node, err := parser.ParseFile(fset, entityFile, nil, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}

	fields := []FieldInfo{}
	pkgPaths := map[string]struct{}{}
	ast.Inspect(node, func(n ast.Node) bool {
		if structDecl, ok := n.(*ast.TypeSpec); ok && structDecl.Name.Name == structName {
			structType, ok := structDecl.Type.(*ast.StructType)
			if !ok {
				return true
			}
			for _, field := range structType.Fields.List {
				if len(field.Names) == 0 {
					continue
				}
				fieldName := field.Names[0].Name
				if field.Tag == nil {
					continue
				}
				gormTag := getGormTag(field.Tag.Value)
				if hasForeignKey(gormTag) {
					continue
				}
				// 获取字段类型
				typeExpr := field.Type
				var fieldType, pkgPath, paramName string
				var entityType bool
				// 如果是自定义类型（非基本类型），添加entity包路径
				var underlyingType, strconvFunc string
				var strconvBase, strconvBitSize int
				switch t := typeExpr.(type) {
				case *ast.Ident:
					fieldType = t.Name
					if !isBuiltinType(fieldType) {
						pkgPath = "entity"
						pkgPaths[pkgPath] = struct{}{}
						// 进一步解析以找到自定义类型的基础类型
						underlyingType, strconvFunc, strconvBase, strconvBitSize = getUnderlyingTypeInfo(entityFile, fieldType)
						// 只有在当前文件中找到类型定义，才认为是EntityType
						if underlyingType != "" {
							entityType = true
							pkgPaths["strings"] = struct{}{}
							pkgPaths["strconv"] = struct{}{}
							pkgPaths["fmt"] = struct{}{}
						}
					}
				case *ast.SelectorExpr:
					fieldType = t.Sel.Name
					if ident, ok := t.X.(*ast.Ident); ok {
						pkgPath = ident.Name
						pkgPaths[pkgPath] = struct{}{}
					}
				case *ast.ArrayType:
					fieldType = "[]" + getArrayElemType(t.Elt)
				case *ast.StarExpr:
					fieldType = "*" + getStarExprType(t.X)
				default:
					continue
				}
				fields = append(fields, FieldInfo{
					Name:           fieldName,
					Type:           fieldType,
					PkgPath:        pkgPath,
					EntityType:     entityType,
					ParamName:      paramName,
					UnderlyingType: underlyingType,
					StrconvFunc:    strconvFunc,
					StrconvBase:    strconvBase,
					StrconvBitSize: strconvBitSize,
				})
			}
		}
		return true
	})

	// 导入包路径

	// 导入包路径
	var imports []string
	for pkgPath := range pkgPaths {
		if pkgPath == "entity" {
			continue
		}
		imports = append(imports, pkgPath)
	}

	// 创建输出目录
	outputDir := "../dao"
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		log.Fatal(err)
	}

	// 创建模板并渲染
	t := template.Must(template.New("dao").
		Funcs(template.FuncMap{"toSnake": utils.ToSnakeCase}).
		Parse(tmpl))
	data := TemplateData{
		StructName: structName,
		Fields:     fields,
		Imports:    imports,
	}

	var buf bytes.Buffer

	err = t.Execute(&buf, data)
	if err != nil {
		log.Fatal(err)
	}

	// 格式化代码
	formattedCode, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("原始代码:\n%s\n", buf.String())
	}

	outputFile := filepath.Join(outputDir, fmt.Sprintf("generated_%s_store.go", utils.ToSnakeCase(structName)))
	// 写入文件
	if err := os.WriteFile(outputFile, formattedCode, 0644); err != nil {
		log.Fatalf("写入文件 %s 失败: %v", outputFile, err)
	}

	fmt.Printf("生成成功: %s\n", outputFile)
}

func getGormTag(tag string) string {
	tag = strings.Trim(tag, "`")
	for _, part := range strings.Split(tag, " ") {
		if strings.HasPrefix(part, "gorm:") {
			return strings.Trim(strings.SplitN(part, ":", 2)[1], `"`)
		}
	}
	return ""
}
func hasForeignKey(tag string) bool {
	for _, part := range strings.Split(tag, ";") {
		if strings.HasPrefix(strings.TrimSpace(part), "foreignKey:") {
			return true
		}
	}
	return false
}

func getArrayElemType(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		return t.Sel.Name
	default:
		return "interface{}"
	}
}

func getStarExprType(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		return t.Sel.Name
	default:
		return "interface{}"
	}
}

// 判断是否为Go的内置类型
func isBuiltinType(typeName string) bool {
	builtinTypes := map[string]struct{}{
		"bool":       {},
		"uint8":      {},
		"uint16":     {},
		"uint32":     {},
		"uint64":     {},
		"int8":       {},
		"int16":      {},
		"int32":      {},
		"int64":      {},
		"float32":    {},
		"float64":    {},
		"complex64":  {},
		"complex128": {},
		"string":     {},
		"int":        {},
		"uint":       {},
		"uintptr":    {},
		"byte":       {},
		"rune":       {},
		"error":      {},
	}
	_, ok := builtinTypes[typeName]
	return ok
}

// getUnderlyingTypeInfo 解析指定文件中的类型定义，获取其基础类型信息
func getUnderlyingTypeInfo(filePath string, typeName string) (string, string, int, int) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filePath, nil, 0)
	if err != nil {
		log.Printf("警告: 解析文件 %s 以获取类型 %s 的基础类型失败: %v\n", filePath, typeName, err)
		return "", "", 0, 0
	}

	var baseType, strconvFunc string
	var strconvBase, strconvBitSize int

	ast.Inspect(node, func(n ast.Node) bool {
		if ts, ok := n.(*ast.TypeSpec); ok {
			if ts.Name.Name == typeName {
				if ident, ok := ts.Type.(*ast.Ident); ok {
					baseType = ident.Name
					switch baseType {
					case "int", "int8", "int16", "int32", "int64":
						strconvFunc = "ParseInt"
						strconvBase = 10
						switch baseType {
						case "int8":
							strconvBitSize = 8
						case "int16":
							strconvBitSize = 16
						case "int32":
							strconvBitSize = 32
						case "int64":
							strconvBitSize = 64
						default: // int
							strconvBitSize = 0 // 0 implies int
						}
					case "uint", "uint8", "uint16", "uint32", "uint64", "byte", "rune":
						strconvFunc = "ParseUint"
						strconvBase = 10
						switch baseType {
						case "uint8", "byte":
							strconvBitSize = 8
						case "uint16":
							strconvBitSize = 16
						case "uint32", "rune":
							strconvBitSize = 32
						case "uint64":
							strconvBitSize = 64
						default: // uint
							strconvBitSize = 0 // 0 implies uint
						}
					case "bool":
						strconvFunc = "ParseBool"
					// case "float32", "float64":
					// 	strconvFunc = "ParseFloat"
					// 	switch baseType {
					// 	case "float32":
					// 		strconvBitSize = 32
					// 	case "float64":
					// 		strconvBitSize = 64
					// 	}
					// string 不在这里处理，因为它不是自定义类型的基础类型转换目标
					default:
						log.Printf("警告: 类型 %s 的基础类型 %s 暂不支持自动生成Slice转换函数\n", typeName, baseType)
					}
					return false // 找到类型定义，停止遍历
				}
			}
		}
		return true
	})

	if baseType == "" {
		log.Printf("警告: 未能在文件 %s 中找到类型 %s 的定义\n", filePath, typeName)
	}

	return baseType, strconvFunc, strconvBase, strconvBitSize
}
