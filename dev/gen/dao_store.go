//go:build ignore

// 为输入的枚举类型和包名，生成一个Go代码文件，该文件中包含一个枚举类型的映射，以及一个用于验证枚举类型的函数。
// 使用 go generate ./... 命令进行生成

package main

import (
	"STUOJ/pkg/utils"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"html/template"
	"log"
	"os"
	"path/filepath"
	"strings"
)

const tmpl = `// Code generated by generate_const; DO NOT EDIT.
package dao

import (
	"STUOJ/internal/infrastructure/repository"
	"STUOJ/internal/infrastructure/repository/entity"
	"STUOJ/internal/model/option"
	"gorm.io/gorm"
	"fmt"
	{{- range.Imports}}
	"{{.}}"
	{{- end}}
)

type _{{.StructName}}Store struct {}

var {{.StructName}}Store = new(_{{.StructName}}Store)

// 插入记录
func (store *_{{.StructName}}Store) Insert(entity_ entity.{{.StructName}}) (entity.{{.StructName}}, error) {
	err := repository.Db.Transaction(func(tx *gorm.DB) error {
		return tx.Create(&entity_).Error
	})
	return entity_, err
}

// 查询记录
func (store *_{{.StructName}}Store) Select(options *option.QueryOptions) ([]map[string]any, error) {
	var entities []map[string]any
	where := options.GenerateQuery()
	err := repository.Db.Transaction(func(tx *gorm.DB) error {
		tx = tx.Model(&entity.{{.StructName}}{})
		tx = where(tx)
		return tx.Find(&entities).Error
	})
	return entities, err
}

// 查询单条记录
func (store *_{{.StructName}}Store) SelectOne(options *option.QueryOptions) (map[string]any, error) {
	var entity_ map[string]any
	where := options.GenerateQuery()
	err := repository.Db.Transaction(func(tx *gorm.DB) error {
		tx = tx.Model(&entity.{{.StructName}}{})
		tx = where(tx)
		return tx.First(&entity_).Error
	})
	return entity_, err
}

// 更新记录
func (store *_{{.StructName}}Store) Updates(entity_ entity.{{.StructName}}, options *option.QueryOptions) (int64, error) {
	var affected int64
	where := options.GenerateQuery()
	err := repository.Db.Transaction(func(tx *gorm.DB) error {
		tx = tx.Model(&entity.{{.StructName}}{})
		tx = where(tx)
		res := tx.Updates(entity_)
		affected = res.RowsAffected
		return res.Error
	})
	return affected, err
}

// 删除记录
func (store *_{{.StructName}}Store) Delete(options *option.QueryOptions) error {
	where := options.GenerateQuery()
	return repository.Db.Transaction(func(tx *gorm.DB) error {
		tx = tx.Model(&entity.{{.StructName}}{})
		tx = where(tx)
		return tx.Delete(&entity.{{.StructName}}{}).Error
	})
}

// 统计数量
func (store *_{{.StructName}}Store) Count(options *option.QueryOptions) (int64, error) {
	var count int64
	where := options.GenerateQuery()
	err := repository.Db.Transaction(func(tx *gorm.DB) error {
		tx = tx.Model(&entity.{{.StructName}}{})
		tx = where(tx)
		return tx.Count(&count).Error
	})
	return count, err
}

func (store *_{{.StructName}}Store) GroupCount(options *option.GroupCountOptions)([]option.GroupCountResult, error){
	var res []option.GroupCountResult
	if ok := options.verify();!ok {
		return nil,fmt.Errorf("分组字段验证失败")
	}
	where := options.GenerateQuery()
	err := repository.Db.Transaction(func(tx *gorm.DB) error {
		tx = tx.Model(&entity.{{.StructName}}{})
		tx = where(tx)
		return tx.Scan(&res).Error
	})
	return res, err
}

func (store *_{{.StructName}}Store) Dto(data map[string]any) entity.{{.StructName}} {
	var entity_ entity.{{.StructName}}
	{{- range .Fields}}
	{{- if .PkgPath}}
	if v, ok := data["{{.Name | toSnake}}"].({{.PkgPath}}.{{.Type}}); ok {
		entity_.{{.Name}} = v
	}
	{{- else}}
	if v, ok := data["{{.Name | toSnake}}"].({{.Type}}); ok {
		entity_.{{.Name}} = v
	}
	{{- end}}
	{{- end}}
	return entity_
}

`

type FieldInfo struct {
	Name    string
	Type    string
	PkgPath string
}

func main() {
	// 解析命令行参数
	var (
		typeName string
	)
	flag.StringVar(&typeName, "struct", "", "结构体类型名称")
	flag.Parse()

	// 校验参数
	if typeName == "" {
		log.Fatal("必须指定-type参数")
	}

	fset := token.NewFileSet()

	pkgs, err := parser.ParseDir(fset, ".", nil, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}
	var (
		targetStruct *ast.StructType
	)

	// 查找目标结构体
	for _, pkgFiles := range pkgs {
		for _, file := range pkgFiles.Files {
			for _, decl := range file.Decls {
				genDecl, ok := decl.(*ast.GenDecl)
				if !ok || genDecl.Tok != token.TYPE {
					continue
				}
				for _, spec := range genDecl.Specs {
					typeSpec, ok := spec.(*ast.TypeSpec)
					if !ok || typeSpec.Name.Name != typeName {
						continue
					}
					if structType, ok := typeSpec.Type.(*ast.StructType); ok {
						targetStruct = structType
						break
					}
				}
			}
		}
	}

	if targetStruct == nil {
		log.Fatalf("未找到类型 %s 对应的结构体", typeName)
	}

	// 解析结构体字段
	var fields []FieldInfo
	pkgPaths := make(map[string]struct{})
	for _, f := range targetStruct.Fields.List {
		if len(f.Names) == 0 {
			continue
		}
		fieldName := f.Names[0].Name
		if f.Tag == nil {
			continue
		}
		gormTag := getGormTag(f.Tag.Value)
		if hasForeignKey(gormTag) {
			continue
		}
		// 获取字段类型
		typeExpr := f.Type
		var fieldType, pkgPath string
		switch t := typeExpr.(type) {
		case *ast.Ident:
			fieldType = t.Name
			// 如果是自定义类型（非基本类型），添加entity包路径
			if !isBuiltinType(fieldType) {
				pkgPath = "entity"
				pkgPaths[pkgPath] = struct{}{}
			}
		case *ast.SelectorExpr:
			fieldType = t.Sel.Name
			if ident, ok := t.X.(*ast.Ident); ok {
				pkgPath = ident.Name
				pkgPaths[pkgPath] = struct{}{}
			}
		case *ast.ArrayType:
			fieldType = "[]" + getArrayElemType(t.Elt)
		case *ast.StarExpr:
			fieldType = "*" + getStarExprType(t.X)
		default:
			continue
		}
		fields = append(fields, FieldInfo{Name: fieldName, Type: fieldType, PkgPath: pkgPath})
	}

	// 导入包路径
	var imports []string
	for pkgPath := range pkgPaths {
		if pkgPath == "entity" {
			continue
		}
		imports = append(imports, pkgPath)
	}

	// 创建输出目录
	outputDir := "../dao"
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		log.Fatal(err)
	}

	// 创建模板并渲染
	t := template.Must(template.New("dao").
		Funcs(template.FuncMap{"toSnake": utils.ToSnakeCase}).
		Parse(tmpl))
	data := map[string]any{
		"StructName": typeName,
		"Fields":     fields,
		"Imports":    imports,
	}

	outputFile := filepath.Join(outputDir, fmt.Sprintf("generated_%s_store.go", utils.ToSnakeCase(typeName)))
	f, err := os.Create(outputFile)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	err = t.Execute(f, data)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf("生成成功: %s\n", outputFile)
}

func getGormTag(tag string) string {
	tag = strings.Trim(tag, "`")
	for _, part := range strings.Split(tag, " ") {
		if strings.HasPrefix(part, "gorm:") {
			return strings.Trim(strings.SplitN(part, ":", 2)[1], `"`)
		}
	}
	return ""
}
func hasForeignKey(tag string) bool {
	for _, part := range strings.Split(tag, ";") {
		if strings.HasPrefix(strings.TrimSpace(part), "foreignKey:") {
			return true
		}
	}
	return false
}

func getArrayElemType(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		return t.Sel.Name
	default:
		return "interface{}"
	}
}

func getStarExprType(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		return t.Sel.Name
	default:
		return "interface{}"
	}
}

// 判断是否为Go的内置类型
func isBuiltinType(typeName string) bool {
	builtinTypes := map[string]struct{}{
		"bool":       {},
		"uint8":      {},
		"uint16":     {},
		"uint32":     {},
		"uint64":     {},
		"int8":       {},
		"int16":      {},
		"int32":      {},
		"int64":      {},
		"float32":    {},
		"float64":    {},
		"complex64":  {},
		"complex128": {},
		"string":     {},
		"int":        {},
		"uint":       {},
		"uintptr":    {},
		"byte":       {},
		"rune":       {},
		"error":      {},
	}
	_, ok := builtinTypes[typeName]
	return ok
}
