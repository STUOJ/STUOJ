package main

import (
	"STUOJ/pkg/utils"
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"html/template"
	"log"
	"os"
	"path/filepath"
	"strings"
)

const templateStr = `// Code generated by generate_const; DO NOT EDIT.
package {{.Package}}

import(
    "STUOJ/internal/model/option"
)

const(
	{{- range .Fields }}
	{{$.StructName}}{{.Name}} = "{{ $.TableName }}.{{ .Name | toSnake }}"
	{{- end }}
)

type {{.StructName}}Field struct {
{{- range .Fields }}
    {{ .Name }} bool
{{- end }}
	Extra option.Selectors
}

func New{{.StructName}}Field() *{{.StructName}}Field {
    return &{{.StructName}}Field{}
}

func (f *{{.StructName}}Field) SelectedColumns() []string {
    columns := make([]string, 0)
{{- range .Fields }}
    if f.{{ .Name }} {
        columns = append(columns, "{{ $.TableName }}.{{ .Name | toSnake }}")
    }
{{- end }}
    columns = append(columns, f.Extra.SelectedColumns()...)
    return columns
}

func (f *{{$.StructName}}Field) AddSelect(selector ...option.Selector){
    f.Extra.AddSelector(selector...)
}

{{ range .Fields }}
func (f *{{$.StructName}}Field) Select{{ .Name }}() *{{$.StructName}}Field {
    f.{{ .Name }} = true
    return f
}
{{- end }}

func (f *{{$.StructName}}Field) SelectAll() *{{$.StructName}}Field{
{{- range .Fields }}
    f.{{ .Name }} = true
{{- end }}
    return f
}`

type FieldInfo struct {
	Name     string
	HaveEnum bool
}

type TemplateData struct {
	Package    string
	StructName string
	TableName  string
	Fields     []FieldInfo
}

func main() {
	structName := flag.String("struct", "", "结构体名称")
	flag.Parse()
	if *structName == "" {
		log.Fatal("必须指定 -struct 参数")
	}

	cwd, err := os.Getwd()
	if err != nil {
		log.Fatalf("获取当前工作目录失败: %v\n", err)
	}

	// 处理单个实体
	err = processEntity(cwd, *structName)
	if err != nil {
		log.Fatalf("处理实体失败: %v\n", err)
	}

}

func processEntity(dir string, structName string) error {
	// 尝试两种文件名格式：下划线分隔和驼峰转蛇形
	entityFile1 := filepath.Join(dir, structName+".go")
	entityFile2 := filepath.Join(dir, strings.Split(utils.ToSnakeCase(structName), "_")[0]+".go")

	var entityFile string
	if _, err := os.Stat(entityFile1); err == nil {
		entityFile = entityFile1
	} else if _, err := os.Stat(entityFile2); err == nil {
		entityFile = entityFile2
	} else {
		return fmt.Errorf("实体文件 %s 或 %s 不存在", entityFile1, entityFile2)
	}

	// 解析domain中的实体结构体
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, entityFile, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("解析文件 %s 失败: %v", entityFile, err)
	}

	var tableName string
	var fields []FieldInfo

	ast.Inspect(node, func(n ast.Node) bool {
		funcDecl, ok := n.(*ast.FuncDecl)
		if ok && funcDecl.Name.Name == "TableName" {
			recvType := funcDecl.Recv.List[0].Type
			if starExpr, ok := recvType.(*ast.StarExpr); ok {
				recvType = starExpr.X
			}
			if ident, ok := recvType.(*ast.Ident); ok && ident.Name == structName {
				for _, stmt := range funcDecl.Body.List {
					retStmt, ok := stmt.(*ast.ReturnStmt)
					if !ok {
						continue
					}
					if len(retStmt.Results) != 1 {
						continue
					}
					if lit, ok := retStmt.Results[0].(*ast.BasicLit); ok && lit.Kind == token.STRING {
						tableName = strings.Trim(lit.Value, `"`)
						break
					}
				}
			}
		}

		typeSpec, ok := n.(*ast.TypeSpec)
		if ok && typeSpec.Name.Name == structName {
			structType, ok := typeSpec.Type.(*ast.StructType)
			if !ok {
				return true
			}
			for _, field := range structType.Fields.List {
				if len(field.Names) == 0 {
					continue
				}
				fieldName := field.Names[0].Name
				if field.Tag == nil {
					continue
				}
				gormTag := getGormTag(field.Tag.Value)
				if hasForeignKey(gormTag) {
					continue
				}
				// 处理带下划线的字段名
				if strings.Contains(fieldName, "_") {
					parts := strings.Split(fieldName, "_")
					for i, part := range parts {
						parts[i] = strings.Title(part)
					}
					fieldName = strings.Join(parts, "")
				}
				fieldInfo := FieldInfo{
					Name:     fieldName,
					HaveEnum: false,
				}
				fields = append(fields, fieldInfo)
			}
		}
		return true
	})

	if tableName == "" {
		return fmt.Errorf("实体 %s 未定义 TableName 方法", structName)
	}

	templateData := TemplateData{
		Package:    "field\n",
		StructName: structName,
		TableName:  tableName,
		Fields:     fields,
	}
	tmpl, err := template.New("field").Funcs(template.FuncMap{
		"toSnake": utils.ToSnakeCase,
	}).Parse(templateStr)
	if err != nil {
		return fmt.Errorf("解析模板失败: %v", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, templateData); err != nil {
		return fmt.Errorf("渲染模板失败: %v", err)
	}

	// 格式化代码
	formattedCode, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Printf("原始代码:\n%s\n", buf.String())
		return fmt.Errorf("格式化代码失败: %v", err)
	}

	// 创建输出目录
	outputDir := "field"
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		log.Fatal(err)
	}

	// 生成代码
	outputPath := filepath.Join(outputDir, "generated_"+strings.ToLower(structName)+"_field.go")

	// 写入文件
	if err := os.WriteFile(outputPath, formattedCode, 0644); err != nil {
		return fmt.Errorf("写入文件 %s 失败: %v", outputPath, err)
	}

	fmt.Printf("生成成功: %s\n", outputPath)
	return nil
}

func getGormTag(tag string) string {
	tag = strings.Trim(tag, "`")
	for _, part := range strings.Split(tag, " ") {
		if strings.HasPrefix(part, "gorm:") {
			return strings.Trim(strings.SplitN(part, ":", 2)[1], `"`)
		}
	}
	return ""
}
func hasForeignKey(tag string) bool {
	for _, part := range strings.Split(tag, ";") {
		if strings.HasPrefix(strings.TrimSpace(part), "foreignKey:") {
			return true
		}
	}
	return false
}
