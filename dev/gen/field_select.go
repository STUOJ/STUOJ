package main

import (
	"STUOJ/pkg/utils"
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"html/template"
	"log"
	"os"
	"path/filepath"
	"strings"
)

const templateStr = `// Code generated by generate_const; DO NOT EDIT.
package {{.Package}}

import(
    "STUOJ/internal/model/option"
)

const(
	{{- range .Fields }}
	{{$.StructName}}{{.Name}} = "{{ $.TableName }}.{{ .Name | toSnake }}"
	{{- end }}
)

type {{.StructName}}Field struct {
{{- range .Fields }}
    {{ .Name }} bool
{{- end }}
	Extra option.Selectors
}

func New{{.StructName}}Field() *{{.StructName}}Field {
    return &{{.StructName}}Field{}
}

func (f *{{.StructName}}Field) SelectedColumns() []string {
    columns := make([]string, 0)
{{- range .Fields }}
    if f.{{ .Name }} {
        columns = append(columns, "{{ $.TableName }}.{{ .Name | toSnake }}")
    }
{{- end }}
    columns = append(columns, f.Extra.SelectedColumns()...)
    return columns
}

func (f *{{$.StructName}}Field) AddSelect(selector ...option.Selector){
    f.Extra.AddSelector(selector...)
}

{{ range .Fields }}
func (f *{{$.StructName}}Field) Select{{ .Name }}() *{{$.StructName}}Field {
    f.{{ .Name }} = true
    return f
}
{{- end }}

func (f *{{$.StructName}}Field) SelectAll() *{{$.StructName}}Field{
{{- range .Fields }}
    f.{{ .Name }} = true
{{- end }}
    return f
}
	
var {{.StructName | toSnake}}GroupField = map[string]struct{}{
	{{- range.Fields }}
	{{if .HaveEnum}}
	"{{.Name | toSnake}}": struct{}{},
	{{end}}
	{{- end }}
}

type {{.StructName}}GroupField struct {
	field string
}

func New{{.StructName}}GroupField(field string) *{{.StructName}}GroupField {
    groupField := &{{.StructName}}GroupField{}
    groupField.SetField(field)
    return groupField
}

func (f *{{.StructName}}GroupField) Verify() bool {
    _, ok := {{.StructName | toSnake}}GroupField[f.field]
    return ok
}

func (f *{{.StructName}}GroupField) SetField(field string) {
    f.field = field
}

func (f *{{$.StructName}}GroupField) Field() string {
    return f.field
}
`

type FieldInfo struct {
	Name     string
	HaveEnum bool
}

type TemplateData struct {
	Package    string
	StructName string
	TableName  string
	Fields     []FieldInfo
}

func main() {

	structName := flag.String("struct", "", "结构体名称")
	flag.Parse()
	if *structName == "" {
		log.Fatal("必须指定 -struct 参数")
	}

	cwd, err := os.Getwd()
	if err != nil {
		log.Fatalf("获取当前工作目录失败: %v\n", err)
	}

	// 处理单个实体
	err = processEntity(cwd, *structName)
	if err != nil {
		log.Fatalf("处理实体失败: %v\n", err)
	}

}

// 存储类型名到其常量值的映射，用于判断是否为枚举类型
type EnumTypeInfo struct {
	TypeName  string
	Constants map[string]bool // 存储常量名
}

// 检测类型是否为枚举类型
func isEnumType(typeName string, enumTypes map[string]*EnumTypeInfo) bool {
	_, ok := enumTypes[typeName]
	return ok
}

func processEntity(dir string, structName string) error {
	file := os.Getenv("GOFILE")
	entityFile := filepath.Join(dir, file)

	// 解析domain中的实体结构体
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, entityFile, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("解析文件 %s 失败: %v", entityFile, err)
	}

	// 收集所有自定义类型及其常量定义
	enumTypes := make(map[string]*EnumTypeInfo)
	ast.Inspect(node, func(n ast.Node) bool {
		// 查找类型定义
		typeSpec, ok := n.(*ast.TypeSpec)
		if ok {
			// 检查是否是基于基本类型的自定义类型
			if _, ok := typeSpec.Type.(*ast.Ident); ok {
				enumTypes[typeSpec.Name.Name] = &EnumTypeInfo{
					TypeName:  typeSpec.Name.Name,
					Constants: make(map[string]bool),
				}
			}
		}

		// 查找常量声明
		genDecl, ok := n.(*ast.GenDecl)
		if ok && genDecl.Tok == token.CONST {
			for _, spec := range genDecl.Specs {
				valueSpec, ok := spec.(*ast.ValueSpec)
				if !ok || valueSpec.Type == nil {
					continue
				}

				// 获取常量类型
				typeIdent, ok := valueSpec.Type.(*ast.Ident)
				if !ok {
					continue
				}

				// 检查类型是否在我们的枚举类型映射中
				enumType, exists := enumTypes[typeIdent.Name]
				if !exists {
					continue
				}

				// 将常量添加到该类型的常量映射中
				for _, name := range valueSpec.Names {
					enumType.Constants[name.Name] = true
				}
			}
		}
		return true
	})

	var tableName string
	var fields []FieldInfo

	ast.Inspect(node, func(n ast.Node) bool {
		funcDecl, ok := n.(*ast.FuncDecl)
		if ok && funcDecl.Name.Name == "TableName" {
			recvType := funcDecl.Recv.List[0].Type
			if starExpr, ok := recvType.(*ast.StarExpr); ok {
				recvType = starExpr.X
			}
			if ident, ok := recvType.(*ast.Ident); ok && ident.Name == structName {
				for _, stmt := range funcDecl.Body.List {
					retStmt, ok := stmt.(*ast.ReturnStmt)
					if !ok {
						continue
					}
					if len(retStmt.Results) != 1 {
						continue
					}
					if lit, ok := retStmt.Results[0].(*ast.BasicLit); ok && lit.Kind == token.STRING {
						tableName = strings.Trim(lit.Value, `"`)
						break
					}
				}
			}
		}

		typeSpec, ok := n.(*ast.TypeSpec)
		if ok && typeSpec.Name.Name == structName {
			structType, ok := typeSpec.Type.(*ast.StructType)
			if !ok {
				return true
			}
			for _, field := range structType.Fields.List {
				if len(field.Names) == 0 {
					continue
				}
				fieldName := field.Names[0].Name
				if field.Tag == nil {
					continue
				}
				gormTag := getGormTag(field.Tag.Value)
				if hasForeignKey(gormTag) {
					continue
				}
				// 处理带下划线的字段名
				if strings.Contains(fieldName, "_") {
					parts := strings.Split(fieldName, "_")
					for i, part := range parts {
						parts[i] = strings.Title(part)
					}
					fieldName = strings.Join(parts, "")
				}

				// 检查字段类型是否为枚举类型
				isEnum := false
				switch t := field.Type.(type) {
				case *ast.Ident:
					// 直接类型名称，如 BlogStatus
					isEnum = isEnumType(t.Name, enumTypes)
				case *ast.SelectorExpr:
					// 带包名的类型，如 entity.BlogStatus
					if _, ok := t.X.(*ast.Ident); ok {
						typeName := t.Sel.Name
						isEnum = isEnumType(typeName, enumTypes)
					}
				}

				fieldInfo := FieldInfo{
					Name:     fieldName,
					HaveEnum: isEnum,
				}
				fields = append(fields, fieldInfo)
			}
		}
		return true
	})

	if tableName == "" {
		return fmt.Errorf("实体 %s 未定义 TableName 方法", structName)
	}

	templateData := TemplateData{
		Package:    "field\n",
		StructName: structName,
		TableName:  tableName,
		Fields:     fields,
	}
	tmpl, err := template.New("field").Funcs(template.FuncMap{
		"toSnake": utils.ToSnakeCase,
	}).Parse(templateStr)
	if err != nil {
		return fmt.Errorf("解析模板失败: %v", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, templateData); err != nil {
		return fmt.Errorf("渲染模板失败: %v", err)
	}

	// 格式化代码
	formattedCode, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Printf("原始代码:\n%s\n", buf.String())
		return fmt.Errorf("格式化代码失败: %v", err)
	}

	// 创建输出目录
	outputDir := "field"
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		log.Fatal(err)
	}

	// 生成代码
	outputPath := filepath.Join(outputDir, "generated_"+strings.ToLower(structName)+"_field.go")

	// 写入文件
	if err := os.WriteFile(outputPath, formattedCode, 0644); err != nil {
		return fmt.Errorf("写入文件 %s 失败: %v", outputPath, err)
	}

	fmt.Printf("生成成功: %s\n", outputPath)
	return nil
}

func getGormTag(tag string) string {
	tag = strings.Trim(tag, "`")
	for _, part := range strings.Split(tag, " ") {
		if strings.HasPrefix(part, "gorm:") {
			return strings.Trim(strings.SplitN(part, ":", 2)[1], `"`)
		}
	}
	return ""
}
func hasForeignKey(tag string) bool {
	for _, part := range strings.Split(tag, ";") {
		if strings.HasPrefix(strings.TrimSpace(part), "foreignKey:") {
			return true
		}
	}
	return false
}
