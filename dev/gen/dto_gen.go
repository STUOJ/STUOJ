//go:build ignore

// 为domain目录下的实体结构体生成dto.go文件
// 例如：go run ../../../utils/gen/dto_gen.go blog

package main

import (
	"STUOJ/pkg/utils"
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

const dtoTmpl = `// Code generated by generate_const; DO NOT EDIT.
 
package {{.PackageName}}

{{if or .NeedsEntity .NeedsTime .NeedsValueObject .NeedsFmt}}import ({{if .NeedsEntity}}
	"STUOJ/internal/infrastructure/repository/entity"{{end}}{{if .NeedsValueObject}}
	"STUOJ/internal/domain/{{.PackageName}}/valueobject"{{end}}{{if .NeedsTime}}
	"time"{{end}}{{if .NeedsFmt}}
	"fmt"{{end}}
){{end}}

func Dto(data map[string]any) {{.StructName}} {
	var entity_ {{.StructName}}
{{range .Fields}}	{{.}}
{{end}}	return entity_
}

func Dtos(datas []map[string]any) []{{.StructName}} {
	var entitys = make([]{{.StructName}}, len(datas))
	for _, e := range datas {
		entitys = append(entitys, Dto(e))
	}
	return entitys
}
`

type FieldInfo struct {
	Name            string
	Type            string
	EntityType      string
	IsValueObject   bool
	ValueObjectType string
}

type TemplateData struct {
	PackageName      string
	StructName       string
	Fields           []string
	NeedsTime        bool
	NeedsEntity      bool
	NeedsValueObject bool
	NeedsFmt         bool
}

func main() {
	// 检查命令行参数
	if len(os.Args) < 2 {
		log.Fatal("Usage: go run dto_gen.go <entity-name>")
	}
	entityName := os.Args[1]

	// 获取当前工作目录，即实体所在的目录
	cwd, err := os.Getwd()
	if err != nil {
		log.Fatalf("获取当前工作目录失败: %v\n", err)
	}

	// 处理单个实体
	err = processEntity(cwd, entityName)
	if err != nil {
		log.Fatalf("处理实体失败: %v\n", err)
	}
}

// 处理单个实体的dto生成
func processEntity(dir string, entityName string) error {
	// 获取包名
	pkgName := filepath.Base(dir)

	// 查找实体结构体定义文件
	entityFile := filepath.Join(dir, entityName+".go")
	if _, err := os.Stat(entityFile); os.IsNotExist(err) {
		return fmt.Errorf("实体文件 %s 不存在", entityFile)
	}

	// 查找对应的entity包中的实体定义
	entityDefFile := filepath.Join("../../../internal/db/entity", entityName+".go")
	if _, err := os.Stat(entityDefFile); os.IsNotExist(err) {
		return fmt.Errorf("实体定义文件 %s 不存在", entityDefFile)
	}

	// 解析entity包中的实体定义，获取原始类型
	entityTypes := make(map[string]string)
	fset := token.NewFileSet()
	entityNode, err := parser.ParseFile(fset, entityDefFile, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("解析文件 %s 失败: %v", entityDefFile, err)
	}

	// 查找entity中的结构体定义
	var entityStructName string
	ast.Inspect(entityNode, func(n ast.Node) bool {
		typeSpec, ok := n.(*ast.TypeSpec)
		if !ok || typeSpec.Type == nil {
			return true
		}

		structType, ok := typeSpec.Type.(*ast.StructType)
		if !ok {
			return true
		}

		// 找到结构体定义
		entityStructName = typeSpec.Name.Name
		if strings.EqualFold(entityStructName, strings.Title(entityName)) {
			// 解析结构体字段
			for _, field := range structType.Fields.List {
				if len(field.Names) == 0 {
					continue
				}

				fieldName := field.Names[0].Name
				fieldType := getFieldType(field.Type)
				entityTypes[fieldName] = fieldType
			}
			return false
		}

		return true
	})

	// 解析domain中的实体结构体
	node, err := parser.ParseFile(fset, entityFile, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("解析文件 %s 失败: %v", entityFile, err)
	}

	// 查找结构体定义
	var structName string
	var fields []FieldInfo
	ast.Inspect(node, func(n ast.Node) bool {
		typeSpec, ok := n.(*ast.TypeSpec)
		if !ok || typeSpec.Type == nil {
			return true
		}

		structType, ok := typeSpec.Type.(*ast.StructType)
		if !ok {
			return true
		}

		// 找到第一个结构体定义
		structName = typeSpec.Name.Name

		// 解析结构体字段
		for _, field := range structType.Fields.List {
			if len(field.Names) == 0 {
				continue
			}

			fieldName := field.Names[0].Name
			fieldType := getFieldType(field.Type)
			isValueObject, valueObjectType := isValueObjectType(fieldType)

			// 获取entity中对应的类型
			entityType := entityTypes[fieldName]

			fields = append(fields, FieldInfo{
				Name:            fieldName,
				Type:            fieldType,
				EntityType:      entityType,
				IsValueObject:   isValueObject,
				ValueObjectType: valueObjectType,
			})
		}

		return false
	})

	if structName == "" {
		return fmt.Errorf("在文件 %s 中未找到结构体定义", entityFile)
	}

	// 生成dto.go文件
	dtoFile := filepath.Join("generated_dto.go")

	// 生成字段处理代码
	fieldStrings, needsTime, needsEntity, needsValueObject, needsFmt := generateFieldStrings(fields, pkgName)

	// 准备模板数据
	templateData := TemplateData{
		PackageName:      pkgName,
		StructName:       structName,
		Fields:           fieldStrings,
		NeedsTime:        needsTime,
		NeedsEntity:      needsEntity,
		NeedsValueObject: needsValueObject,
		NeedsFmt:         needsFmt,
	}

	// 渲染模板
	tmpl, err := template.New("dto").Parse(dtoTmpl)
	if err != nil {
		return fmt.Errorf("解析模板失败: %v", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, templateData); err != nil {
		return fmt.Errorf("渲染模板失败: %v", err)
	}

	// 格式化代码
	formattedCode, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Printf("原始代码:\n%s\n", buf.String())
		return fmt.Errorf("格式化代码失败: %v", err)
	}

	// 写入文件
	if err := os.WriteFile(dtoFile, formattedCode, 0644); err != nil {
		return fmt.Errorf("写入文件 %s 失败: %v", dtoFile, err)
	}

	fmt.Printf("生成成功: %s %s\n", structName, dtoFile)
	return nil
}

// 获取字段类型的字符串表示
func getFieldType(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		pkg, ok := t.X.(*ast.Ident)
		if !ok {
			return ""
		}
		return pkg.Name + "." + t.Sel.Name
	default:
		return ""
	}
}

// 判断是否为值对象类型
func isValueObjectType(fieldType string) (bool, string) {
	if strings.HasPrefix(fieldType, "valueobject.") {
		return true, strings.TrimPrefix(fieldType, "valueobject.")
	}
	// 检查是否是其他可能的值对象类型命名模式
	parts := strings.Split(fieldType, ".")
	if len(parts) == 2 && parts[0] == "valueobject" {
		return true, parts[1]
	}
	return false, ""
}

// 生成字段处理代码
func generateFieldStrings(fields []FieldInfo, pkgName string) ([]string, bool, bool, bool, bool) {
	// 标记是否需要导入time、entity、valueobject和fmt包
	needsTime := false
	needsEntity := false
	needsValueObject := false
	needsFmt := false
	var result []string

	for _, field := range fields {
		var fieldStr string
		jsonKey := utils.ToSnakeCase(field.Name)

		// 根据字段类型生成不同的处理代码
		switch {
		case field.IsValueObject:
			// 值对象类型
			// 先从entity中读取正确的类型
			if field.EntityType == "string" {
				fieldStr = fmt.Sprintf("if v, ok := data[\"%s\"].(string); ok {\n\t\tentity_.%s = valueobject.New%s(v)\n\t}", jsonKey, field.Name, field.ValueObjectType)
			} else if strings.HasSuffix(field.EntityType, field.ValueObjectType) {
				// 处理自定义类型，如Email、Username等
				fieldStr = fmt.Sprintf("if v, ok := data[\"%s\"].(entity.%s); ok {\n\t\tentity_.%s = valueobject.New%s(string(v))\n\t}", jsonKey, field.EntityType, field.Name, field.ValueObjectType)
				needsEntity = true
			} else {
				fieldStr = fmt.Sprintf("if v, ok := data[\"%s\"].(%s); ok {\n\t\tentity_.%s = valueobject.New%s(fmt.Sprint(v))\n\t}", jsonKey, field.EntityType, field.Name, field.ValueObjectType)
				needsFmt = true
			}
			needsValueObject = true

		case field.Type == "time.Time":
			// 时间类型
			if field.EntityType == "time.Time" {
				fieldStr = fmt.Sprintf("if v, ok := data[\"%s\"].(time.Time); ok {\n\t\tentity_.%s = v\n\t}", jsonKey, field.Name)
			} else {
				// 处理其他类型到time.Time的转换
				fieldStr = fmt.Sprintf("if v, ok := data[\"%s\"].(%s); ok {\n\t\tentity_.%s = time.Unix(int64(v), 0)\n\t}", jsonKey, field.EntityType, field.Name)
			}
			needsTime = true

		case strings.HasPrefix(field.Type, "entity."):
			// 枚举类型
			enumType := strings.TrimPrefix(field.Type, "entity.")
			fieldStr = fmt.Sprintf("if v, ok := data[\"%s\"].(entity.%s); ok {\n\t\tentity_.%s = v\n\t}", jsonKey, enumType, field.Name)
			needsEntity = true

		case field.EntityType == "uint64" && field.Type == "int64":
			// uint64 -> int64 转换
			fieldStr = fmt.Sprintf("if v, ok := data[\"%s\"].(uint64); ok {\n\t\tentity_.%s = int64(v)\n\t}", jsonKey, field.Name)

		case field.EntityType == "uint32" && field.Type == "int32":
			// uint32 -> int32 转换
			fieldStr = fmt.Sprintf("if v, ok := data[\"%s\"].(uint32); ok {\n\t\tentity_.%s = int32(v)\n\t}", jsonKey, field.Name)

		case field.EntityType == "uint16" && field.Type == "int16":
			// uint16 -> int16 转换
			fieldStr = fmt.Sprintf("if v, ok := data[\"%s\"].(uint16); ok {\n\t\tentity_.%s = int16(v)\n\t}", jsonKey, field.Name)

		case field.EntityType == "uint8" && field.Type == "int8":
			// uint8 -> int8 转换
			fieldStr = fmt.Sprintf("if v, ok := data[\"%s\"].(uint8); ok {\n\t\tentity_.%s = int8(v)\n\t}", jsonKey, field.Name)

		case field.EntityType == "uint" && field.Type == "int":
			// uint -> int 转换
			fieldStr = fmt.Sprintf("if v, ok := data[\"%s\"].(uint); ok {\n\t\tentity_.%s = int(v)\n\t}", jsonKey, field.Name)

		case strings.HasPrefix(field.EntityType, "uint") || strings.HasPrefix(field.EntityType, "int"):
			// 其他整数类型，使用entity中的类型
			fieldStr = fmt.Sprintf("if v, ok := data[\"%s\"].(%s); ok {\n\t\t// 转换为domain中的类型\n\t\tentity_.%s = %s(v)\n\t}", jsonKey, field.EntityType, field.Name, field.Type)

		case field.Type == "string":
			// 字符串类型
			fieldStr = fmt.Sprintf("if v, ok := data[\"%s\"].(string); ok {\n\t\tentity_.%s = v\n\t}", jsonKey, field.Name)

		case field.Type == "bool":
			// 布尔类型
			fieldStr = fmt.Sprintf("if v, ok := data[\"%s\"].(bool); ok {\n\t\tentity_.%s = v\n\t}", jsonKey, field.Name)

		default:
			// 其他类型，使用entity中的类型进行读取，然后转换为domain中的类型
			if field.EntityType != field.Type && field.EntityType != "" && field.Type != "" {
				fieldStr = fmt.Sprintf("if v, ok := data[\"%s\"].(%s); ok {\n\t\tentity_.%s = %s(v)\n\t}", jsonKey, field.EntityType, field.Name, field.Type)
			} else if field.EntityType != "" {
				fieldStr = fmt.Sprintf("if v, ok := data[\"%s\"].(%s); ok {\n\t\tentity_.%s = v\n\t}", jsonKey, field.EntityType, field.Name)
			} else if field.Type != "" {
				fieldStr = fmt.Sprintf("if v, ok := data[\"%s\"].(any); ok {\n\t\t// 类型不明确，尝试转换\n\t\tentity_.%s = v\n\t}", jsonKey, field.Name)
			} else {
				// 如果两种类型都为空，使用any类型
				fieldStr = fmt.Sprintf("if v, ok := data[\"%s\"].(any); ok {\n\t\tentity_.%s = v\n\t}", jsonKey, field.Name)
			}
		}

		result = append(result, fieldStr)
	}

	return result, needsTime, needsEntity, needsValueObject, needsFmt
}
