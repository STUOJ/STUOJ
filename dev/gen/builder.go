//go:build ignore

// 为domain目录下的实体结构体生成builder.go文件
// 使用 go generate ./... 命令进行生成

package main

import (
	"STUOJ/pkg/utils"
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

const tmpl = `// Code generated by generate_const; DO NOT EDIT.

package {{.PackageName}}

import (
	{{if .NeedValueObject}}"STUOJ/internal/domain/{{.PackageName}}/valueobject"{{end}}
	{{if .NeedEntity}}"STUOJ/internal/infrastructure/repository/entity"{{end}}

	{{range $import, $_ := .ExtraImports}}
	"{{$import}}"
	{{end}}
)

type Option func(*{{.StructName}})

func New{{.StructName}}(options...Option) *{{.StructName}} {
	{{.VarName}} := &{{.StructName}}{}
	for _, option := range options {
		option({{.VarName}})
	}
	return {{.VarName}}
}

{{range .Fields}}
func With{{.Name}}({{.ParamName}} {{.ParamType}}) Option {
	return func({{.VarName}} *{{.StructName}}) {
		{{.VarName}}.{{.Name}} = {{if .IsValueObject}}valueobject.New{{.ValueObjectType}}({{.ParamName}}){{else}}{{.ParamName}}{{end}}
	}
}
{{end}}

func ({{.VarName}} *{{.StructName}}) verify() error {
	{{range.Fields}}
	{{if .IsValueObject}}
	if err := {{.VarName}}.{{.Name}}.Verify(); err != nil {
		return err
	}
	{{end}}
	{{end}}
	return nil
}

{{if .HaveEntity}}
func ({{.VarName}} *{{.StructName}}) existField() []string{
	fields := []string{}
	{{range.Fields}}
	{{if .IsValueObject}}
	if {{.VarName}}.{{.Name}}.Exist() {
		fields = append(fields, "{{.Name | toSnake}}")
	}
	{{end}}
	{{end}}
	return fields
}

// toEntity converts domain model to entity
func ({{.VarName}} *{{.StructName}}) toEntity() entity.{{.StructName}} {
	return entity.{{.StructName}}{
		{{range .ToEntityFields}} {{.}}
		{{end}}
	}
}

// fromEntity converts entity to domain model
func ({{.VarName}} *{{.StructName}}) fromEntity(entity entity.{{.StructName}}) *{{.StructName}} {
	{{range .FromEntityFields}} {{.}}
	{{end}}
	return {{.VarName}}
}

func Dto(data map[string]any) {{.StructName}} {
	var entity_ {{.StructName}}
{{range .MapFields}}	{{.}}
{{end}}	return entity_
}

func Dtos(datas []map[string]any) []{{.StructName}} {
	var entitys = make([]{{.StructName}}, len(datas))
	for _, e := range datas {
		entitys = append(entitys, Dto(e))
	}
	return entitys
}
{{end}}
`

type Field struct {
	Name            string
	ParamName       string
	ParamType       string
	VarName         string
	StructName      string
	IsValueObject   bool
	ValueObjectType string
}

type FieldInfo struct {
	Name            string
	Type            string
	EntityType      string
	IsValueObject   bool
	ValueObjectType string
	VarName         string
}

type TemplateData struct {
	PackageName      string
	StructName       string
	VarName          string
	Fields           []Field
	MapFields        []string
	ToEntityFields   []string
	FromEntityFields []string
	NeedEntity       bool
	NeedValueObject  bool
	NeedTime         bool
	NeedIO           bool
	HaveEntity       bool
	ExtraImports     map[string]bool
}

// main 函数是程序的入口点
func main() {
	// 检查命令行参数
	if len(os.Args) < 2 {
		fmt.Println("Usage: go run builder.go <entity_name>")
		return
	}

	entityName := os.Args[1]

	// 获取当前工作目录，即实体所在的目录
	cwd, err := os.Getwd()
	if err != nil {
		log.Fatalf("获取当前工作目录失败: %v\n", err)
	}

	// 处理单个实体
	err = processDomain(cwd, entityName)
	if err != nil {
		log.Fatalf("处理实体失败: %v\n", err)
	}
}

// processDomain 处理单个实体的builder生成
func processDomain(dir string, entityName string) error {
	// 获取包名
	pkgName := filepath.Base(dir)

	// 查找实体结构体定义文件
	entityFile := filepath.Join(dir, entityName+".go")
	if _, err := os.Stat(entityFile); os.IsNotExist(err) {
		return fmt.Errorf("实体文件 %s 不存在", entityFile)
	}

	// 解析domain中的实体结构体
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, entityFile, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("解析文件 %s 失败: %v", entityFile, err)
	}

	// 查找结构体定义
	var structName string
	var fields []Field
	var mapFields []string
	var toEntityFields []string
	var fromEntityFields []string
	var haveEntity bool
	var needEntity bool
	var needValueObject bool
	var needTime bool
	var needIO bool
	extraImports := make(map[string]bool)

	ast.Inspect(node, func(n ast.Node) bool {
		typeSpec, ok := n.(*ast.TypeSpec)
		if !ok || typeSpec.Type == nil {
			return true
		}

		structType, ok := typeSpec.Type.(*ast.StructType)
		if !ok {
			return true
		}

		// 找到第一个结构体定义
		structName = typeSpec.Name.Name
		varName := strings.ToLower(structName[:1]) + structName[1:]

		// 解析结构体字段
		for _, field := range structType.Fields.List {
			if len(field.Names) == 0 {
				continue
			}

			fieldName := field.Names[0].Name
			fieldType := getFieldType(field.Type)
			isValueObject, valueObjectType := isValueObjectType(fieldType)

			// 确定参数类型
			var paramType string
			if isValueObject {
				// 值对象类型，需要查找对应的构造函数参数类型
				paramType = getValueObjectParamType(pkgName, valueObjectType)
				needValueObject = true
				if strings.HasPrefix(paramType, "entity.") {
					needEntity = true
				}
			} else if strings.HasPrefix(fieldType, "entity.") {
				// 实体类型
				paramType = fieldType
				needEntity = true
			} else if strings.Contains(fieldType, ".") {
				// 处理所有其他外部包引用
				processExternalPackage(fieldType, extraImports)
				paramType = fieldType
			} else if strings.Contains(fieldType, ".") {
				// 处理所有其他外部包引用
				processExternalPackage(fieldType, extraImports)
				paramType = fieldType
			} else {
				// 其他类型
				paramType = fieldType
			}

			// 添加字段信息
			fields = append(fields, Field{
				Name:            fieldName,
				ParamName:       strings.ToLower(fieldName[:1]) + fieldName[1:],
				ParamType:       paramType,
				VarName:         varName,
				StructName:      structName,
				IsValueObject:   isValueObject,
				ValueObjectType: valueObjectType,
			})
		}

		return false
	})

	mapFields, toEntityFields, fromEntityFields, err = processEntity(dir, entityName, fields)
	if err == nil {
		haveEntity = true
	}

	if structName == "" {
		return fmt.Errorf("在文件 %s 中未找到结构体定义", entityFile)
	}

	// 生成builder.go文件
	builderFile := filepath.Join(dir, "generated_builder.go")

	// 准备模板数据
	templateData := TemplateData{
		PackageName:      pkgName,
		StructName:       structName,
		VarName:          strings.ToLower(structName[:1]) + structName[1:],
		MapFields:        mapFields,
		ToEntityFields:   toEntityFields,
		FromEntityFields: fromEntityFields,
		HaveEntity:       haveEntity,
		Fields:           fields,
		NeedEntity:       needEntity,
		NeedValueObject:  needValueObject,
		NeedTime:         needTime,
		NeedIO:           needIO,
		ExtraImports:     extraImports,
	}

	// 渲染模板
	tmpl, err := template.New("builder").Funcs(template.FuncMap{"toSnake": utils.ToSnakeCase}).Parse(tmpl)
	if err != nil {
		return fmt.Errorf("解析模板失败: %v", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, templateData); err != nil {
		return fmt.Errorf("渲染模板失败: %v", err)
	}

	// 格式化代码
	formattedCode, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Printf("原始代码:\n%s\n", buf.String())
		return fmt.Errorf("格式化代码失败: %v", err)
	}

	// 写入文件
	if err := os.WriteFile(builderFile, formattedCode, 0644); err != nil {
		return fmt.Errorf("写入文件 %s 失败: %v", builderFile, err)
	}

	fmt.Printf("生成成功: %s %s\n", structName, builderFile)
	return nil
}

func processEntity(dir, entityName string, domainField []Field) ([]string, []string, []string, error) {
	entityDefFile := filepath.Join("../../../internal/infrastructure/repository/entity", entityName+".go")
	if _, err := os.Stat(entityDefFile); os.IsNotExist(err) {
		return nil, nil, nil, fmt.Errorf("实体文件 %s 不存在", entityDefFile)
	}
	// 解析entity包中的实体定义，获取原始类型
	entityTypes := make(map[string]string)
	fset := token.NewFileSet()
	entityNode, err := parser.ParseFile(fset, entityDefFile, nil, parser.ParseComments)
	if err != nil {
		return nil, nil, nil, fmt.Errorf("解析文件 %s 失败: %v", entityDefFile, err)
	}

	// 查找entity中的结构体定义
	var entityStructName string
	ast.Inspect(entityNode, func(n ast.Node) bool {
		typeSpec, ok := n.(*ast.TypeSpec)
		if !ok || typeSpec.Type == nil {
			return true
		}

		structType, ok := typeSpec.Type.(*ast.StructType)
		if !ok {
			return true
		}

		// 找到结构体定义
		entityStructName = typeSpec.Name.Name
		if strings.EqualFold(entityStructName, strings.Title(entityName)) {
			// 解析结构体字段
			for _, field := range structType.Fields.List {
				if len(field.Names) == 0 {
					continue
				}

				fieldName := field.Names[0].Name
				fieldType := getFieldType(field.Type)
				entityTypes[fieldName] = fieldType
			}
			return false
		}

		return true
	})

	if entityStructName == "" {
		return nil, nil, nil, fmt.Errorf("在文件 %s 中未找到实体结构体定义", entityDefFile)
	}

	var fields []FieldInfo

	for _, field := range domainField {
		fieldType, ok := entityTypes[field.Name]
		if !ok {
			continue
		}
		fields = append(fields, FieldInfo{
			Name:            field.Name,
			Type:            field.ParamType,
			EntityType:      fieldType,
			IsValueObject:   field.IsValueObject,
			ValueObjectType: field.ValueObjectType,
			VarName:         field.VarName,
		})
	}

	// 生成mapFields
	mapFields := generateMapFieldStrings(fields)

	// 生成toEntityFields
	toEntityFields := generateToEntityFields(fields)

	// 生成fromEntityFields
	fromEntityFields := generateFromEntityFields(fields)

	return mapFields, toEntityFields, fromEntityFields, nil

}

// getFieldType 获取字段类型的字符串表示
// 返回完整的类型字符串，包括包名和类型名
func getFieldType(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		pkg, ok := t.X.(*ast.Ident)
		if !ok {
			return ""
		}
		return pkg.Name + "." + t.Sel.Name
	case *ast.StarExpr: // 处理指针类型
		return "*" + getFieldType(t.X)
	case *ast.ArrayType: // 处理数组类型
		return "[]" + getFieldType(t.Elt)
	case *ast.MapType: // 处理映射类型
		return "map[" + getFieldType(t.Key) + "]" + getFieldType(t.Value)
	case *ast.InterfaceType: // 处理接口类型
		return "interface{}"
	default:
		return ""
	}
}

// isValueObjectType 判断是否为值对象类型
func isValueObjectType(fieldType string) (bool, string) {
	if strings.HasPrefix(fieldType, "valueobject.") {
		return true, strings.TrimPrefix(fieldType, "valueobject.")
	}
	// 检查是否是其他可能的值对象类型命名模式
	parts := strings.Split(fieldType, ".")
	if len(parts) == 2 && parts[0] == "valueobject" {
		return true, parts[1]
	}
	return false, ""
}

// processExternalPackage 处理外部包引用，将包名添加到extraImports映射中
func processExternalPackage(fieldType string, extraImports map[string]bool) {
	// 处理指针类型
	if strings.HasPrefix(fieldType, "*") {
		processExternalPackage(strings.TrimPrefix(fieldType, "*"), extraImports)
		return
	}

	// 处理数组类型
	if strings.HasPrefix(fieldType, "[]") {
		processExternalPackage(strings.TrimPrefix(fieldType, "[]"), extraImports)
		return
	}

	// 处理映射类型
	if strings.HasPrefix(fieldType, "map[") {
		// 提取键和值类型
		contentStart := strings.Index(fieldType, "[") + 1
		contentEnd := strings.LastIndex(fieldType, "]")
		if contentStart > 0 && contentEnd > contentStart {
			keyType := fieldType[contentStart:contentEnd]
			valueType := fieldType[contentEnd+1:]
			// 处理键类型
			processExternalPackage(keyType, extraImports)
			// 处理值类型
			processExternalPackage(valueType, extraImports)
		}
		return
	}

	// 处理普通包引用
	if strings.Contains(fieldType, ".") {
		parts := strings.Split(fieldType, ".")
		if len(parts) >= 2 {
			pkgName := parts[0]
			// 排除已知的特殊包
			if pkgName != "valueobject" && pkgName != "entity" {
				extraImports[pkgName] = true
			}
		}
	}
}

// getValueObjectParamType 获取值对象构造函数的参数类型
// 通过解析AST获取New函数的返回值类型中的泛型参数类型
func getValueObjectParamType(pkgName, valueObjectType string) string {
	// 尝试查找值对象的构造函数文件
	voFilePath := filepath.Join("../../../internal/domain", pkgName, "valueobject", utils.ToSnakeCase(valueObjectType)+".go")
	if _, err := os.Stat(voFilePath); os.IsNotExist(err) {
		// 如果文件不存在，默认使用string类型
		return "string"
	}

	// 解析值对象文件
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, voFilePath, nil, parser.ParseComments)
	if err != nil {
		// 解析失败，默认使用string类型
		return "string"
	}

	// 查找New+ValueObjectType函数的参数类型或model.Valueobject泛型类型
	var paramType string
	ast.Inspect(node, func(n ast.Node) bool {
		// 检查是否为New函数
		funcDecl, ok := n.(*ast.FuncDecl)
		if ok && funcDecl.Name != nil && funcDecl.Name.Name == "New"+valueObjectType {
			// 获取函数的第一个参数类型
			if funcDecl.Type.Params != nil && len(funcDecl.Type.Params.List) > 0 {
				paramType = getFieldType(funcDecl.Type.Params.List[0].Type)
				return false
			}
			return true
		}

		// 检查是否为model.Valueobject泛型类型
		typeSpec, ok := n.(*ast.TypeSpec)
		if ok && typeSpec.Name.Name == valueObjectType {
			if structType, ok := typeSpec.Type.(*ast.StructType); ok {
				for _, field := range structType.Fields.List {
					if selector, ok := field.Type.(*ast.SelectorExpr); ok {
						if ident, ok := selector.X.(*ast.Ident); ok && ident.Name == "model" && selector.Sel.Name == "Valueobject" {
							// 获取泛型参数类型
							if len(field.Names) > 0 {
								paramType = getFieldType(field.Type)
								return false
							}
						}
					}
				}
			}
		}
		return true
	})

	// 如果没有找到参数类型，默认使用string
	if paramType == "" {
		return "string"
	}
	return paramType
}

// 生成字段处理代码
func generateMapFieldStrings(fields []FieldInfo) []string {
	var result []string

	for _, field := range fields {
		var fieldStr string
		jsonKey := utils.ToSnakeCase(field.Name)

		// 根据字段类型生成不同的处理代码
		if field.IsValueObject {
			if field.Type == field.EntityType {
				fieldStr = fmt.Sprintf(`if v, ok := data["%s"].(%s); ok {
					entity_.%s = valueobject.New%s(v)
				}`, jsonKey, field.EntityType, field.Name, field.ValueObjectType)
			} else if strings.Contains(field.Type, "int") && strings.Contains(field.EntityType, "int") {
				fieldStr = fmt.Sprintf(`if v, ok := data["%s"].(%s); ok {
					entity_.%s = valueobject.New%s(%s(v))
				}`, jsonKey, field.EntityType, field.Name, field.ValueObjectType, field.Type)
			} else if strings.TrimPrefix(field.Type, "entity.") == field.EntityType {
				fieldStr = fmt.Sprintf(`if v, ok := data["%s"].(%s); ok {
					entity_.%s = valueobject.New%s(v)
				}`, jsonKey, field.Type, field.Name, field.ValueObjectType)
			}
		} else {
			if field.Type == field.EntityType {
				fieldStr = fmt.Sprintf(`if v, ok := data["%s"].(%s); ok {
					entity_.%s = v
				}`, jsonKey, field.EntityType, field.Name)
			} else if strings.Contains(field.Type, "int") && strings.Contains(field.EntityType, "int") {
				fieldStr = fmt.Sprintf(`if v, ok := data["%s"].(%s); ok {
					entity_.%s = %s(v)
				}`, jsonKey, field.EntityType, field.Name, field.Type)
			} else if strings.TrimPrefix(field.Type, "entity.") == field.EntityType {
				fieldStr = fmt.Sprintf(`if v, ok := data["%s"].(%s); ok {
					entity_.%s = v
				}`, jsonKey, field.Type, field.Name)
			}
		}
		result = append(result, fieldStr)
	}

	return result
}

func generateToEntityFields(fields []FieldInfo) []string {
	var result []string

	for _, field := range fields {
		var fieldStr string

		// 根据字段类型生成不同的处理代码
		if field.IsValueObject {
			if field.Type == field.EntityType || strings.TrimPrefix(field.Type, "entity.") == field.EntityType {
				fieldStr = fmt.Sprintf(`%s: %s.%s.Value(),`, field.Name, field.VarName, field.Name)
			} else if strings.Contains(field.Type, "int") && strings.Contains(field.EntityType, "int") {
				fieldStr = fmt.Sprintf(`%s: %s(%s.%s.Value()),`, field.Name, field.EntityType, field.VarName, field.Name)
			}
		} else {
			if field.Type == field.EntityType || strings.TrimPrefix(field.Type, "entity.") == field.EntityType {
				fieldStr = fmt.Sprintf(`%s: %s.%s,`, field.Name, field.VarName, field.Name)
			} else if strings.Contains(field.Type, "int") && strings.Contains(field.EntityType, "int") {
				fieldStr = fmt.Sprintf(`%s: %s(%s.%s),`, field.Name, field.EntityType, field.VarName, field.Name)
			}
		}
		result = append(result, fieldStr)
	}
	return result
}

func generateFromEntityFields(fields []FieldInfo) []string {
	var result []string

	for _, field := range fields {
		var fieldStr string

		// 根据字段类型生成不同的处理代码
		if field.IsValueObject {
			if field.Type == field.EntityType || strings.TrimPrefix(field.Type, "entity.") == field.EntityType {
				fieldStr = fmt.Sprintf(`%s.%s = valueobject.New%s(entity.%s)`, field.VarName, field.Name, field.ValueObjectType, field.Name)
			} else if strings.Contains(field.Type, "int") && strings.Contains(field.EntityType, "int") {
				fieldStr = fmt.Sprintf(`%s.%s = valueobject.New%s(%s(entity.%s))`, field.VarName, field.Name, field.ValueObjectType, field.Type, field.Name)
			}
		} else {
			if field.Type == field.EntityType || strings.TrimPrefix(field.Type, "entity.") == field.EntityType {
				fieldStr = fmt.Sprintf(`%s.%s = entity.%s`, field.VarName, field.Name, field.Name)
			} else if strings.Contains(field.Type, "int") && strings.Contains(field.EntityType, "int") {
				fieldStr = fmt.Sprintf(`%s.%s = %s(entity.%s)`, field.VarName, field.Name, field.Type, field.Name)
			}
		}
		result = append(result, fieldStr)
	}
	return result
}
