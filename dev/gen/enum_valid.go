//go:build ignore

// 为输入的枚举类型和包名，生成一个Go代码文件，该文件中包含一个枚举类型的映射，以及一个用于验证枚举类型的函数。
// 使用 go generate ./... 命令进行生成

package main

import (
	"bytes"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"html/template"
	"log"
	"os"
)

const tmpl = `// Code generated by generate_const; DO NOT EDIT.
package entity

{{range $typeName, $mapping := .Values}}
var {{$typeName}}Enum = map[{{$typeName}}]string{
{{- range $key, $value := $mapping }}
    {{$key}}: "{{$value}}",
{{- end }}
}

func (v {{$typeName}}) IsValid() bool {
    _, ok := {{$typeName}}Enum[v]
    return ok
}

func (v {{$typeName}}) ValidValues() []int {
    var values []int
    for key := range {{$typeName}}Enum {
        values = append(values, int(key))
    }
    return values
}
{{end}}`

// main 是程序的入口，根据命令行参数生成枚举常量的Go代码文件。
// 它解析当前目录的AST，收集指定类型的常量值，并生成对应的枚举结构。
func main() {
	// 检查命令行参数数量，确保提供了类型名和包名，否则终止程序
	if len(os.Args) < 2 {
		log.Fatal("Usage: go run generate_const.go <type-name>")
	}
	typeName := os.Args[1]

	fset := token.NewFileSet()
	// 解析当前目录下的Go源文件，收集所有包和文件的信息，包含注释以便后续处理
	pkgs, err := parser.ParseDir(fset, ".", nil, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}

	values := make(map[string]map[string]string) // 外层map的key是类型名

	// 遍历所有包和文件
	for _, pkg := range pkgs {
		for _, file := range pkg.Files {
			ast.Inspect(file, func(n ast.Node) bool {
				decl, ok := n.(*ast.GenDecl)
				if !ok || decl.Tok != token.CONST {
					return true
				}

				for _, spec := range decl.Specs {
					vspec := spec.(*ast.ValueSpec)
					if vspec.Type == nil {
						continue
					}

					ident, ok := vspec.Type.(*ast.Ident)
					if !ok {
						continue
					}

					typeName := ident.Name
					if _, exists := values[typeName]; !exists {
						values[typeName] = make(map[string]string)
					}

					// 收集常量值
					for i, name := range vspec.Names {
						if len(vspec.Values) <= i {
							continue
						}
						if lit, ok := vspec.Values[i].(*ast.BasicLit); ok {
							values[typeName][lit.Value] = name.Name
						}
					}
				}
				return true
			})
		}
	}

	// 加载并验证模板，准备生成代码所需的数据结构
	t := template.Must(template.New("enum").Parse(tmpl))
	data := map[string]interface{}{
		"TypeName": typeName,
		"Values":   values,
	}

	var buf bytes.Buffer
	// 执行模板生成原始代码内容
	if err := t.Execute(&buf, data); err != nil {
		log.Fatal(err)
	}

	// 格式化生成的Go代码
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatal(err)
	}

	// 将生成的代码写入指定文件，设置权限为0644
	filename := "generated_enums.go"
	if err := os.WriteFile(filename, formatted, 0644); err != nil {
		log.Fatal(err)
	}
}
